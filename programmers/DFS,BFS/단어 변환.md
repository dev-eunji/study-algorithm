# 단어 변환

> [프로그래머스 코딩테스트 연습 > DFS/BFS > 단어 변환](https://programmers.co.kr/learn/courses/30/lessons/43163)
> 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges

- Level3
- DFS/BFS (출제 빈도: 높음, 평균 점수: 낮음)

## 해결 과정

1. 시작 단어를 root 로 DFS 탐색을 한다.
2. 현재의 단어와 방문하지 않은 words 중 알파벳이 하나만 차이나는 word가 있다면 계속 탐색한다.
3. words에 target이 없을때 또는 탐색이 완료 된 후 visited에 target이 없다면 0을
   visited에 target이 있다면 visited의 길이(몇 단계)를 반환한다.

## 코드 1

```kotlin
fun solution(begin: String, target: String, words: Array<String>): Int {
    if (!words.contains(target)) return 0
    return dfs(begin, target, words)
}

fun dfs(begin: String, target: String, words: Array<String>): Int {
    val visited = mutableListOf<String>()
    val needVisit = mutableListOf<String>()
    needVisit.add(begin)

    while (needVisit.isNotEmpty()) {
        if (visited.contains(target)) break

        val node = needVisit.removeAt(needVisit.size - 1)
        if (!visited.contains(node)) {
            visited.add(node)
            for (word in words) {
                if(check(node, word)) {
                    needVisit.add(word)
                }
            }
        }
    }
    if(visited.contains(target)) return visited.size - 1
    else return 0
}

fun check(s1: String, s2: String) : Boolean {
    var diff = 0
    for(i in s1.indices) {
        if(diff > 1) return false
        if(s1[i] != s2[i]) diff += 1
    }
    return diff == 1
}
```

## 코드 2(orange4912)

```kotlin
class Solution {
    val result = mutableListOf<String>()
    fun solution(begin: String, target: String, words: Array<String>): Int {
//        val visited = MutableList(words.size) { false }
//        dfs(begin, target, words, visited, begin)
        return bfs(begin, target, words)
//        return result.map {
//            it.split("->")
//        }.minOf { it.size - 1 }
    }

    private fun dfs(begin: String, target: String, words: Array<String>, visited: MutableList<Boolean>, visitWord: String) {
        if(begin == target) {
            result.add(visitWord)
        }
        for (i in words.indices) {
            if (!visited[i] && begin.diff(words[i]) == 1) {
                visited[i] = true
                dfs(words[i], target, words, visited, "$visitWord -> ${words[i]}")
                visited[i] = false
            }
        }
    }

    data class Node(val nextWord: String, val edge: Int)
    private fun bfs(begin: String, target: String, words: Array<String>): Int {
        val queue: Queue<Node> = LinkedList()
        queue.add(Node(begin, 0))
        val visited = MutableList(words.size) { false }
        while(!queue.isEmpty()) {
            val current = queue.poll()
            if(current.nextWord == target) {
                return current.edge
            }
            for (i in words.indices) {
                if (!visited[i] && current.nextWord.diff(words[i]) == 1) {
                    visited[i] = true
                    queue.add(Node(words[i], current.edge + 1))
                }
            }
        }
        return 0
    }

    fun String.diff(other:String):Int {
        return this.filterIndexed { index, c -> c != other[index] }.map { 1 }.sum()
    }
}

```

## 배운 점

- 두 String의 다른 알파벳 숫자가 1개 인지를 체크하는 check(s1: String, s2: String) : Boolean 메소드 대신에
  아래와 같이 보다 Kotlin 스럽게 작성할 수 있다.

  ```
  fun String.diff(other:String):Int =
      return this.filterIndexed { idx, c -> c != other[idx] }.map { 1 }.sum()

  if(node.diff(word) == 1)
  ```

- dfs, bfs 복습 (최단 거리 문제는 bfs 효율적이다. 다만 효율성 문제 및 범위가 크지 않으면 편한데로 풀어도 된다.)

- [DFS/BFS](https://dev-eunji.github.io/algorithm/2021/08/21/bfs-dfs/)
