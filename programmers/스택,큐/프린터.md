# í”„ë¦°í„°

> [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµ > ìŠ¤íƒ/í > í”„ë¦°í„°](https://programmers.co.kr/learn/courses/30/lessons/42587)
> ì¶œì²˜: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì½”ë”© í…ŒìŠ¤íŠ¸ ì—°ìŠµ, https://programmers.co.kr/learn/challenges

- Level2
- Queue

## í•´ê²° ê³¼ì •

1. ìœ„ì¹˜ë„ ê°™ì´ ì•Œì•„ì•¼ ë˜ê¸° ë•Œë¬¸ì— `Pair` ìë£Œí˜•ì„ ì‚¬ìš©í–ˆë‹¤.
2. í˜„ì¬ priorities ì¤‘ ì œì¼ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ì €ì¥í•˜ê³ ,
3. ì•ì—ì„œ ë¶€í„° ê²€ì‚¬í•˜ë©´ì„œ (`queue`) ì œì¼ ë†’ì€ ìš°ì„ ìˆœìœ„ë¼ë©´ remove, order++ / ì•„ë‹ˆë¼ë©´ ë§¨ ë’¤ì— ë‹¤ì‹œ ë„£ëŠ”ë‹¤.
4. ê²€ì‚¬ì¤‘ì¸ ë…¸ë“œrk ì œì¼ ë†’ì€ ìš°ì„ ìˆœìœ„ì´ë©´ì„œ index ê°€ locationê³¼ ê°™ë‹¤ë©´ order ê°’ì„ ë°˜í™˜í•œë‹¤.

## ì½”ë“œ 1

```kotlin
class Solution {
    fun solution(priorities: IntArray, location: Int): Int {
        var answer = -1
        priorities.mapIndexed { idx, priority ->  Pair(priority, idx) }.toMutableList().let { list ->
            var order = 0
            var max = list.maxBy { it.first }
            while(list.isNotEmpty()) {
                val node = list.removeAt(0)
                if (node == max) {
                    order += 1
                    if (node.second == location) {
                        answer = order
                        return@let
                    }
                    max = list.maxBy { it.first }
                } else {
                    list.add(node)
                }
            }
        }
        return answer
    }
}
```

## ì½”ë“œ 2: ArrayDeque ì‚¬ìš©

```kotlin
fun solution(priorities: IntArray, location: Int): Int {
    var answer = 0
    var queue = ArrayDeque<Pair<Int,Int>>()
    priorities.forEachIndexed { idx, priority ->
        queue.offer(Pair(idx, priority))
    }

    var order = 0
    while(queue.isNotEmpty()){
        val node = queue.poll()
        if(queue.any { node.second < it.second }) {
            queue.offer(node)
        } else {
            order += 1
            if(node.first == location) return order
        }
    }
    return order
}
```

## ì½”ë“œ 3: orange4912 java PriorityQueue ì‚¬ìš© ğŸ‘

```kotlin
fun solution(priorities: IntArray, location: Int): Int {
    val priorityQueue: PriorityQueue<Int> = PriorityQueue(Collections.reverseOrder())
    var answer = 0

    priorities.forEach {
        priorityQueue.add(it)
    }
    while (!priorityQueue.isEmpty()) {
        priorities.forEachIndexed { index, priority ->
            if (priority == priorityQueue.peek()) {
                answer++
                if (index == location) {
                    return answer
                }
                priorityQueue.poll()
            }
        }
    }
    return -1
}
```

## ë°°ìš´ ì 

- `mapIndexed` ë¡œ map í•¨ìˆ˜ì—ì„œ index ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- `ArrayDeque<>()` ë¡œ íë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
  - `offer()`, `poll()`
- `if(queue.any { node.second < it.second }) {` : íì— í˜„ì¬ ë…¸ë“œì˜ ìš°ì„ ìˆœìœ„ë³´ë‹¤ í° ìš°ì„ ìˆœìœ„ë¥¼ ê°–ëŠ” ë…¸ë“œê°€ ìˆë‹¤ë©´
  - ê¼­ ìµœëŒ€ê°’ì„ êµ¬í•  í•„ìš”í•˜ ì—†ë‹¤.
