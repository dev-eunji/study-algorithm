## 전력망을 둘로 나누기

> [프로그래머스 코딩테스트 연습 > Weekly Challenge > 전력망을 둘로 나누기](https://programmers.co.kr/learn/courses/30/lessons/86971)
> 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges

## 해결 과정

1. wires 를 돌면서, 하나씩 연결이 끊어져 있다고 가정을 해본다. (`if(idx != idx2)`)
2. 입력받은 wires 를 그래프(`HashMap<Int, MutableList<Int>>()`)로 변환한다. 이때, 양방향 그래프로 저장해야한다. (`a -> b, b -> a`)
3. 노드들을 돌면서

## 코드 1

```kotlin
var count = 0
fun solution(n: Int, wires: Array<IntArray>): Int {
    var answer = Int.MAX_VALUE
    wires.indices.forEach {  idx ->
        val graph = HashMap<Int, MutableList<Int>>()
        val visited = BooleanArray(n+1) { false }
        val lst = mutableListOf<Int>()
        wires.forEachIndexed { idx2, wire ->
            if(idx != idx2) {
                val a = wire[0]
                val b = wire[1]
                if (!graph.containsKey(a)) graph[a] = mutableListOf()
                if (!graph.containsKey(b)) graph[b] = mutableListOf()
                graph[a]!!.add(b)
                graph[b]!!.add(a)
            }
        }
        for(i in 1..n) {
            if(!visited[i]) {
                count = 0
                dfs(i, graph, visited)
                lst.add(count)
            }
        }
        val diff = lst.max()!! - lst.min()!!
        if(answer > diff) answer = diff
    }
    return answer
}

private fun dfs(from: Int, graph: HashMap<Int, MutableList<Int>>, visited: BooleanArray) {
    if(visited[from]) return
    visited[from] = true
    count += 1
    graph[from]?.forEach { to ->
        dfs(to, graph, visited)
    }
}
```

## 배운 점
