## ì „ë ¥ë§ì„ ë‘˜ë¡œ ë‚˜ëˆ„ê¸°

> [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµ > Weekly Challenge > ì „ë ¥ë§ì„ ë‘˜ë¡œ ë‚˜ëˆ„ê¸°](https://programmers.co.kr/learn/courses/30/lessons/86971)
> ì¶œì²˜: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì½”ë”© í…ŒìŠ¤íŠ¸ ì—°ìŠµ, https://programmers.co.kr/learn/challenges

## í•´ê²° ê³¼ì • ğŸ‘

1. wiresë¥¼ ëŒë©´ì„œ, í•˜ë‚˜ì”© ì—°ê²°ì´ ëŠì–´ì ¸ ìˆë‹¤ê³  ê°€ì •ì„ í•´ë³¸ë‹¤. (`if(idx != idx2)`)
2. ì…ë ¥ë°›ì€ wiresë¥¼ ê·¸ë˜í”„(`HashMap<Int, MutableList<Int>>()`)ë¡œ ë³€í™˜í•œë‹¤. ì´ë•Œ, ì–‘ë°©í–¥ ê·¸ë˜í”„ë¡œ ì €ì¥í•´ì•¼í•œë‹¤. (`a -> b, b -> a`)
3. ë…¸ë“œë“¤ì„ ëŒë©´ì„œ í•´ë‹¹ ë…¸ë“œì— ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´, ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ í•˜ê³ , íŠ¹ì • ë…¸ë“œì— ë°©ë¬¸í•  ë•Œ count + 1 í•´ì¤€ë‹¤.
4. ì—°ê²°ì´ í•˜ë‚˜ ëŠê²¼ì„ ë•Œ ë‚˜ë‰˜ê²Œ ë˜ëŠ” ë‘ ê·¸ë£¹ì˜ ë…¸ë“œ ìˆ˜ì˜ ì°¨ì´ë¥¼ ì²´í¬í•˜ë©°, ì°¨ì´ì˜ ìµœì†Ÿê°’ì„ ë°˜í™˜í•œë‹¤.

## ì½”ë“œ 1

```kotlin
var count = 0
fun solution(n: Int, wires: Array<IntArray>): Int {
    var answer = Int.MAX_VALUE
    wires.indices.forEach {  idx ->
        val graph = HashMap<Int, MutableList<Int>>()
        val visited = BooleanArray(n+1) { false }
        val lst = mutableListOf<Int>()
        wires.forEachIndexed { idx2, wire ->
            if(idx != idx2) {
                val a = wire[0]
                val b = wire[1]
                if (!graph.containsKey(a)) graph[a] = mutableListOf()
                if (!graph.containsKey(b)) graph[b] = mutableListOf()
                graph[a]!!.add(b)
                graph[b]!!.add(a)
            }
        }
        for(i in 1..n) {
            if(!visited[i]) {
                count = 0
                dfs(i, graph, visited)
                lst.add(count)
            }
        }
        val diff = lst.max()!! - lst.min()!!
        if(answer > diff) answer = diff
    }
    return answer
}

private fun dfs(from: Int, graph: HashMap<Int, MutableList<Int>>, visited: BooleanArray) {
    if(visited[from]) return
    visited[from] = true
    count += 1
    graph[from]?.forEach { to -> dfs(to, graph, visited) }
}
```

## ì½”ë“œ 2 orange4912 study

```kotlin
fun solution(n: Int, wires: Array<IntArray>): Int {
    var answer: Int = wires.size - 1

    wires.forEach { disConnected ->
        val graph = MutableList<MutableList<Int>>(n + 1) { mutableListOf() }
        // ì—°ê²° ëŠê¸°
        wires.forEach {
            if (disConnected != it) {
                graph[it[0]].add(it[1])
                graph[it[1]].add(it[0])
            }
        }

        // val first = dfs(graph, disConnected[0], BooleanArray(graph.size + 1))
        // val second = dfs(graph, disConnected[1], BooleanArray(graph.size + 1))
        val first = bfs(graph, disConnected[0], BooleanArray(graph.size + 1))
        val second = bfs(graph, disConnected[1], BooleanArray(graph.size + 1))

        answer = Math.min(Math.abs(first - second) , answer)
    }

    return answer
}

fun bfs(graph: MutableList<MutableList<Int>>, from: Int, visited: BooleanArray): Int {
    val queue = LinkedList<Int>()
    queue.add(from)
    visited[from] = true

    var visitedCount = 1
    while (!queue.isEmpty()) {
        val node = queue.poll()
        graph[node].forEach {
            if (!visited[it]) {
                queue.add(it)  
                visited[it] = true
                visitedCount++
            }
        }
    }
    return visitedCount
}

fun dfs(graph: MutableList<MutableList<Int>>, from: Int, visited: BooleanArray): Int {
    if (visited[from]) return 0
    visited[from] = true

    var visitedCount = 1
    graph[from].forEach {
        visitedCount += dfs(graph, it, visited)
    }
    return visitedCount
}
```

## ë°°ìš´ ì 

1. ê·¸ë˜í”„ê°€ ëª‡ê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ë‰˜ëŠ”ì§€, ê·¸ë¦¬ê³  ê° ê·¸ë£¹ì€ ëª‡ê°œì˜ ë…¸ë“œë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆëŠ”ì§€ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
2. ì¸ì • ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ íƒìƒ‰ì„ ë°°ì› ê³ , ì—°ê²° ëŠê¸°ë¥¼ ë°°ìš¸ìˆ˜ ìˆì—ˆë‹¤. 
